<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>title</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link rel="stylesheet" href="resources/arca.css" type="text/css" />
    <link rel="stylesheet" href="resources/arca_fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">










&lt;!-- END HEADER --&gt; 

class: title-slide, center, middle

#.title[Introduzione a R]

#.subtitle[Giornata 3 - Programmazione in R]

&lt;img src="img/arca_logo.svg" width="10%" style="display: block; margin: auto;" /&gt;

###.location[Corsi ARCA - @DPSS]

###.author[Filippo Gambarota]

---

# Programmazion in R

Quello che vedremo in questa sezione sono i principali **costrutti della programmazione** e la loro applicazione in R. Ci sono alcuni punti da considerare:

- Sono concetti trasversali estremamente utili
- Sono alla base di qualcunque **funzionalità già implementata in R**
- Vi permettono di fare qualunque cosa con il linguaggio

---

# Programmazion in R - Disclaimer

Ci sono delle cose che per tempo e complessità non possiamo affrontare e che sono R specifiche. Per questi aspetti avanzati del linguaggio, il libro [**Advanced R**](https://adv-r.hadley.nz/) è la cosa migliore


```r
put_image("adv_R.png")
```

&lt;img src="img/adv_R.png" width="90" style="display: block; margin: auto;" /&gt;

---

class: section, center, middle

# Costrutti della programmazione in R

---
# Costrutti della programmazione in R

- Funzioni
- Programmazione condizionale
- Programmazione iterativa

---
# Funzioni

Analogalmente alle *funzioni matematiche* la funzione in programmazione consiste nell' **astrarre** una serie di operazioni (nel nostro caso una porzione di codice) definendo una serie di operazioni che forniti degli *input* forniscono degli *output* eseguendo una serie di *operazioni*

---
# Funzioni

Prendiamo l'equazione di una retta: `\(y = 2x + 3\)` dove `\(3\)`


```r
x &lt;- 1:10
y &lt;- 2*x + 3
plot(x, y, xlim = c(0, 10), ylim = c(0, 30), type = "l")
```

&lt;img src="4_programmazione_files/figure-html/unnamed-chunk-3-1.png" width="2100" style="display: block; margin: auto;" /&gt;

---
# Funzioni

Se vogliamo *astrarre* questa operazione in modo da renderla più generale e utile dobbiamo definire:

- **argomenti funzione**: quelle che in matematica sono le *variabili*
- **corpo funzione**: le **operazioni** che la funzione deve eseguire usando gli argomenti
- **output funzione**: cosa la funzione deve **restituire** come risultato

---
# Funzioni - Argomenti

Gli **argomenti** sono quelle parti variabili della funzione che vengono definiti e poi sono necessari ad eseguire la funzione stessa. Se vogliamo *astrarre* la retta che abbiamo visto prima dobbiamo definire alcune parti come **variabili**:

La retta `\(y = mx + q\)` dove `\(m\)` è la pendenza, `\(x\)` sono i valori della variabile `\(x\)` e `\(q\)` è l'intercetta (valore di `\(y\)` quando `\(x = 0\)`). Quindi possiamo definire in R:


```r
retta &lt;- function(m, x, q){ # argomenti
    # body
    # output
}
```

---
# Funzioni - Body

Il corpo della funzione sono le operazioni da eseguire utilizzando gli argomenti in input. Nel caso della retta semplicemente moltiplicare `\(m\)` per ogni valore di `\(x\)` e aggiungere `\(q\)`. In questo modo otteniamo tutti i valori di `\(y\)`:


```r
retta &lt;- function(m, x, q){ # argomenti
    y &lt;- m*x + q
    
    # output
}
```

---
# Funzioni - Output

L'output è il **risultato che la funzione ci restituisce** dopo aver eseguito tutte le operazioni. Nel nostro caso della retta, vogliamo ottenere il rispettivo valore di `\(y\)` per ogni valore di `\(x\)` inserito:


```r
retta &lt;- function(m, x, q){ # argomenti
    y &lt;- m*x + q
    
    return(y) # restituisce y
}
```

---
# Funzioni - Risultato finale

.pull-left[


```r
retta &lt;- function(m, x, q){ # argomenti
    y &lt;- m*x + q
    
    return(y) # restituisce y
}

x &lt;- 1:10
m &lt;- 0.3
q &lt;- 0

y &lt;- retta(m, x, q)
```
]

.pull-right[
&lt;img src="4_programmazione_files/figure-html/unnamed-chunk-8-1.png" width="2100" style="display: block; margin: auto;" /&gt;
]

---
class: section, center, middle

# Programmazione condizionale

---
# Programmazione condizionale

In programmazione solitamente è necessario non solo eseguire una serie di operazione **MA** eseguire delle operazione in funzione di alcune **condizioni**

Facciamo un esempio pratico, la funzione `summary()` in R fornisce un risultato diverso in base al tipo di input. Come è possibile tutto questo? Tramite l'utilizzo di **condizioni**:


```r
x &lt;- 1:10 # vettore numerico
y &lt;- factor(rep(c("a", "b", "c"), each = 10)) # vettore di stringhe

summary(x)
```

```
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    1.00    3.25    5.50    5.50    7.75   10.00
```

```r
summary(y)
```

```
##  a  b  c 
## 10 10 10
```

---
# Programmazione condizionale

Anche se non sappiamo quali operazioni svolga la funzione `summary()` possiamo immaginare una cosa simile


```r
summary &lt;- function(argomento){
    
    # se l'argomento è un vettore numerico
    # esegui --&gt; operazioni a,b,c
    
    # se l'argomento è un vettore stringa
    # esegui --&gt; operazioni d,e,f
    
    # ...
}
```

---
# Programmazione condizionale

Il concetto di `se &lt;condizione&gt; allora fai &lt;operazione&gt;` si traduce in programmazione tramite quelli che si chiamano `if statement`:


```r
put_image("if_chart.png")
```

&lt;img src="img/if_chart.png" width="192" style="display: block; margin: auto;" /&gt;

---
# Programmazione condizionale

Per lavorare con gli `if statements` dobbiamo avere chiaro:

- il concetto di *operatori logici* ovvero `TRUE` e `FALSE`
- il concetto di *operazioni logiche* `TRUE and TRUE = TRUE`

---
# Programmazione condizionale

Quando una sola condizione non basta...


```r
put_image("ifelse_chart.png")
```

&lt;img src="img/ifelse_chart.png" width="192" style="display: block; margin: auto;" /&gt;

---
# Programmazione condizionale

Per poter capire quale struttura condizionale utilizzare è importante capire bene il problema che dobbiamo risolvere.

Ritornando all'esempio della funzione `summary()`, immaginiamo di avere 2 tipi di dati in R; stringhe e numeri.

In questo caso è sufficiente avere un `if statement` che controlla se l'elemento è una stringa/numero e per tutto il resto applicare l'opposto.

---
# Programmazione condizionale - Tip

Esiste una famiglia di funzioni con prefisso `is.*` che fornisce `TRUE` quando la tipologia di oggetto corrisponde a quella richiesta e `FALSE` in caso contrario.


```r
x &lt;- 1:10

is.numeric(x)
```

```
## [1] TRUE
```

```r
is.factor(x)
```

```
## [1] FALSE
```

```r
is.character(x)
```

```
## [1] FALSE
```

Possiamo usare queste funzioni per creare un flusso condizionale nella nostra funzione `summary()`

---
# Programmazione condizionale

Scriviamo una funzione che restituisca la `media` quando il vettore è numerico e la tabella di frequenza (con la funzione `table()`)


```r
my_summary &lt;- function(x){
    
    # testiamo la condizione
    
    if(is.numeric(x)){
        return(mean(x))
    }else{
        return(table(x))
    }
}

x &lt;- 1:10
my_summary(x)
```

```
## [1] 5.5
```

```r
x &lt;- rep(c("a","b","c"), c(10, 2, 8))
my_summary(x)
```

```
## x
##  a  b  c 
## 10  2  8
```

---
class: section, center, middle

# Programmazione iterativa

---
# Programmazione iterativa

Il concetto di *iterazione* è alla base di qualsiasi operazione nei linguaggi di programmazione.

In R molte delle operazioni sono vettorizzate. Questo rende il linguaggio più efficiente e pulito MA nasconde il concetto di *iterazione*

---

# Programmazione iterativa

Esempio: se io vi chiedo di usare la funzione `print()` per scrivere `"hello world"` nella console 10 volte, come fate?


```r
msg &lt;- "Hello World"
print(msg)
```

```
## [1] "Hello World"
```

```r
print(msg)
```

```
## [1] "Hello World"
```

```r
print(msg)
```

```
## [1] "Hello World"
```

```r
print(msg)
```

```
## [1] "Hello World"
```

```r
print(msg)
```

```
## [1] "Hello World"
```

```r
print(msg)
```

```
## [1] "Hello World"
```

```r
print(msg)
```

```
## [1] "Hello World"
```

```r
print(msg)
```

```
## [1] "Hello World"
```

```r
print(msg)
```

```
## [1] "Hello World"
```

```r
print(msg)
```

```
## [1] "Hello World"
```

# Programmazione iterativa

Quello che ci manca è un modo di ripetere una certa operazione, senza effettivamente ripetere il codice manualmente.

Ci sono vari costrutti che ci permettono di ripetere operazioni:

- Cicli `for`
- Cicli `while`
- `*apply` family
- altri

---
# For


```r
put_image("for_loop.png")
```

&lt;img src="img/for_loop.png" width="173" style="display: block; margin: auto;" /&gt;

---
# For

La scrittura di un ciclo `for` è:


```r
for(i in 1:n){
    # operazioni
}
```

---
# Scomponiamo il ciclo for

Ci sono diversi elementi:

- `for(){}`: è l'implementazione in R (in modo simile all'`if statement`)
- `i`: questo viene chiamato *iteratore* o *indice*. E' un indice generico che può assumere qualsiasi valore e nome. Per convenzione viene chiamato `i`, `j` etc. Questo tiene conto del numero di iterazioni che il nostro ciclo deve fare
- `in &lt;valori&gt;`: questo indica i valori che assumerà l'*iteratore* all'interno del ciclo
- `{ # operazioni }`: sono le operazioni che i ciclo deve eseguire

---
# Hello world come ciclo for


```r
# vogliamo che il ciclo ripeta l'operazione 10 volte

for(i in 1:10){
    print("hello world")
}
```

```
## [1] "hello world"
## [1] "hello world"
## [1] "hello world"
## [1] "hello world"
## [1] "hello world"
## [1] "hello world"
## [1] "hello world"
## [1] "hello world"
## [1] "hello world"
## [1] "hello world"
```

---
# Ma l'iteratore?

La potenza del ciclo `for` sta nel fatto che l'iteratore `i` assume i valori del vettore specificato dopo `in`, uno alla volta:


```r
for(i in 1:10){
    print(i)
}
```

```
## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
## [1] 6
## [1] 7
## [1] 8
## [1] 9
## [1] 10
```

---
# For con iteratore vs senza

Questa è una distinzione importante quanto sottile, notate la differenza tra questi due cicli:

.pull-left[


```r
vec &lt;- 1:5

for(i in 1:length(vec)){
    print(vec[i])
}
```

```
## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
```

]

.pull-right[


```r
vec &lt;- 1:5

for(i in vec){
    print(i)
}
```

```
## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
```

]

---
# While

Il ciclo `while` è una versione più generale del ciclo for. Per funzionare utilizza una *condizione logica* e non un iteratore e un range di valori come nel `for`.


```r
while(condizione){
    # operazioni
}
```

Dove il ciclo continuearà fino a che la `condizione` è vera

---
# While - (Fun)

Provate a scrivere questo ciclo `while` e vedere cosa succede:


```r
x &lt;- 10

while (x &lt; 15) {
    print(x)
}
```

Chi mi sa spiegare il risultato?

---
# While

Questo esercizio è utile per capire che il `while` è un ciclo non pre-determinato e quindi necessita sempre di un modo per essere interrotto, facendo diventare la condizione falsa.


```r
x &lt;- 5

while (x &lt; 15) {
    print(x)
    x &lt;- x + 1
}
```

```
## [1] 5
## [1] 6
## [1] 7
## [1] 8
## [1] 9
## [1] 10
## [1] 11
## [1] 12
## [1] 13
## [1] 14
```

---
# Applicazioni dei cicli

Gli esempi finora sono semplici ma poco utili. Quando il queste strutture iterative sono veramente utili?

Molte delle funzioni che utilizziamo come ad esempio `sum()`, `mean()`, etc. hanno al loro interno una sturttura iterativa

Immaginiamo di non avere la funzione `sum()` e di volerla ricreare, come facciamo? Idee?

---
# Somma come iterazione

Scomponiamo concettualmente la somma, sommiamo i numeri da 1 a 10:

- prendo il primo e lo sommo al secondo (`somma = 1 + 2`)
- prendo la `somma` e la sommo al 3 elemento `somma = somma + 3`
- ...

In pratica abbiamo:

- il nostro vettore da sommare
- un oggetto `somma` che accumula progressivamente le somme precedenti

---
# Somma come iterazione


```r
somma &lt;- 0 # inizializziamo la somma a 0
x &lt;- 1:10

for(i in seq_along(x)){
    somma &lt;- somma + x[i]
}
```

---
# Somma come iterazione

Mettiamo tutto dentro una funzione


```r
my_sum &lt;- function(x){
    somma &lt;- 0 # inizializziamo la somma a 0

    for(i in seq_along(x)){
        somma &lt;- somma + x[i]
    }
    
    return(somma)
}

x &lt;- rnorm(100)

my_sum(x)
```

```
## [1] 1.853724
```

```r
sum(x)
```

```
## [1] 1.853724
```

---
class: section, center, middle

# Ma in R c'è qualcosa di meglio...

---
# Ma in R c'è qualcosa di meglio...

In R, l'utilizzo **esplicito** dei cicli `for` non è molto diffuso, per 2 motivi:

- R è un linguaggio fortemente **funzionale**
- R è un linguaggio spesso **vettorizzato**
- I cicli `for` sono molto verbosi e non sempre leggibili
- I cicli `for` in R, se non scritti bene, possono essere *estremamente lenti*

---
class: section, center, middle

# `*apply` family

---
# `*apply` family

Immaginate di avere una `lista` di vettori, e di voler applicare la stessa funzione/i ad ogni elemento della lista. Come fare? ^[1]

- applico manualmente la funzione selezionando gli elementi
- ciclo `for` che itera sugli elementi della lista e applica la funzione/i
- ...


```r
my_list &lt;- list(
    vec1 &lt;- rnorm(100),
    vec2 &lt;- runif(100),
    vec3 &lt;- rnorm(100),
    vec4 &lt;- rnorm(100)
)
```

.footnote[
Hadley Wickam - The joy of functional programming - [link](https://www.youtube.com/watch?v=bzUmK0Y07ck&amp;t=1453s)
]

---
# `*apply` family

Applichiamo `media`, `mediana` e `deviazione standard`:

.pull-left[


```r
means &lt;- vector(mode = "numeric", length = length(my_list))
medians &lt;- vector(mode = "numeric", length = length(my_list))
stds &lt;- vector(mode = "numeric", length = length(my_list))

for(i in 1:length(my_list)){
    means[i] &lt;- mean(my_list[[i]])
    medians[i] &lt;- median(my_list[[i]])
    stds[i] &lt;- sd(my_list[[i]])
}
```
]

.pull-right[


```r
means
```

```
## [1] -0.11808663  0.46415245 -0.13860373 -0.04563265
```

```r
medians
```

```
## [1]  0.03945573  0.42673325 -0.09977593 -0.03458850
```

```r
stds
```

```
## [1] 0.8853891 0.2699502 0.9366235 0.9899087
```

]

---
# `*apply` family

Funziona tutto! ma:

- il `for` è molto laborioso da scrivere gli indici sia per la lista che per il vettore che stiamo popolando
- dobbiamo *pre-allocare delle variabili* (per il motivo della velocità che dicevo)
- 8 righe di codice (per questo esempio semplice)

---
# `*apply` family

In R è presente una famiglia di funzioni `*apply` come `lapply`, `sapply`, etc. che permettono di ottenere lo stesso risultato in modo più conciso, rapido e semplice:


```r
means &lt;- sapply(my_list, mean)
medians &lt;- sapply(my_list, median)
stds &lt;- sapply(my_list, sd)

means
```

```
## [1] -0.11808663  0.46415245 -0.13860373 -0.04563265
```

```r
medians
```

```
## [1]  0.03945573  0.42673325 -0.09977593 -0.03458850
```

```r
stds
```

```
## [1] 0.8853891 0.2699502 0.9366235 0.9899087
```

---
# `*apply` family - Bonus

Prima di introdurre l'`*apply` family un piccolo bonus. Sfruttando il fatto che in R **tutto è un oggetto** possiamo scrivere in modo ancora più conciso:


```r
my_funs &lt;- list(median = median, mean = mean, sd = sd)

lapply(my_list, function(vec) sapply(my_funs, function(fun) fun(vec)))
```

```
## [[1]]
##      median        mean          sd 
##  0.03945573 -0.11808663  0.88538908 
## 
## [[2]]
##    median      mean        sd 
## 0.4267333 0.4641524 0.2699502 
## 
## [[3]]
##      median        mean          sd 
## -0.09977593 -0.13860373  0.93662351 
## 
## [[4]]
##      median        mean          sd 
## -0.03458850 -0.04563265  0.98990865
```

Amazing! ora cerchiamo di dare un senso a queste righe di codice!

---
# `*apply` family


```r
*apply(&lt;lista&gt;, &lt;funzione&gt;)
```

- cosa può essere la `lista`?
    - lista
    - dataframe
    - vettore
- cosa può essere la `funzione`? 
    - funzione *base* o importata *pacchetto*
    - funzione *custom*
    - funzione *anonima*
    
---
# `*apply` family - intuizione

Prima di analizzare l'`*apply` family, credo sia utile un ulteriore parallelismo con il ciclo `for` che abbiamo visto. `*apply` non è altro che un ciclo `for`, leggermente semplificato:

.pull-left[


```r
vec &lt;- 1:5
for(i in vec){
    print(i)
}
```

```
## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
```

]

.pull-right[


```r
vec &lt;- 1:5
res &lt;- sapply(vec, print)
```

```
## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
```

]

---
# `*apply` family - spoiler funzione anonima

Quindi come il ciclo `for` scritto come `i in vec` assegna al valore `i` un elemento per volta dell'oggetto `vec`, internamente le funzioni `*apply` prendono il primo elemento dell'oggetto in input (`lista`) e applicano direttamente la funzione che abbiamo scelto.

C'è un modo per rendere esplicito questo, anche nelle funzioni `*apply`:

.pull-left[

```r
vec &lt;- 1:5
res &lt;- sapply(vec, print)
```

```
## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
```
]

.pull-right[

```r
vec &lt;- 1:5
res &lt;- sapply(vec, function(i) print(i))
```

```
## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
```
]

---
# `*apply` e funzioni custom


```r
center_var &lt;- function(x){
    x - mean(x)
}

my_list &lt;- list(
    vec1 = runif(10),
    vec2 = runif(10),
    vec3 = runif(10)
)

lapply(my_list, center_var)
```

```
## $vec1
##  [1] -0.33153782 -0.37438365 -0.07717602 -0.24398183  0.37055422
##  [6]  0.05526991  0.50901338 -0.24430596  0.28049281  0.05605496
## 
## $vec2
##  [1] -0.292391743  0.072875603 -0.190824182  0.062444252  0.293993472
##  [6] -0.448258546 -0.030405116  0.146481283 -0.006862743  0.392947720
## 
## $vec3
##  [1] -0.022492558 -0.005056755  0.137259948  0.312092212 -0.463729519
##  [6] -0.218640318  0.227056410 -0.338205757 -0.031398346  0.403114683
```

---
# `*apply` e funzioni anonime

Una funzione anonima è una funzione non salvata in un oggetto ma scritta per essere **eseguita direttamente**, all'interno di altre funzioni che lo permettono:


```r
lapply(my_list, function(x) x - mean(x))
```

```
## $vec1
##  [1] -0.33153782 -0.37438365 -0.07717602 -0.24398183  0.37055422
##  [6]  0.05526991  0.50901338 -0.24430596  0.28049281  0.05605496
## 
## $vec2
##  [1] -0.292391743  0.072875603 -0.190824182  0.062444252  0.293993472
##  [6] -0.448258546 -0.030405116  0.146481283 -0.006862743  0.392947720
## 
## $vec3
##  [1] -0.022492558 -0.005056755  0.137259948  0.312092212 -0.463729519
##  [6] -0.218640318  0.227056410 -0.338205757 -0.031398346  0.403114683
```

Come per i cicli `for` (ricordo che `*apply` e `for` sono identici), `x` è solo un placeholder (analogo di `i`) e può essere qualsiasi lettera o nome

---
# Tutte le tipologie di `*apply`

Vediamo tutti i tipi di `*apply` che ci sono. Alcuni sono più *utili* altri più *robusti* e altri ancora poco utilizzati:

- `lapply()`: la funzione di base
- `sapply()`: `simplified-apply`
- `tapply()`: poco utilizzata, utile con i *fattori*
- `apply()`: utile per i *dataframe/matrici*
- `mapply()`: versione multivariata, utilizza *più liste contemporaneamente*
- `vapply()`: utilizzata dentro le funzioni e pacchetti

---
# `lapply`

`lapply` sta per list-apply e restituisce sempre una lista, applicando la funzione ad ogni elemento della lista in input:


```r
res &lt;- lapply(my_list, mean)
res
```

```
## $vec1
## [1] 0.3948843
## 
## $vec2
## [1] 0.4930509
## 
## $vec3
## [1] 0.5873119
```

```r
class(res)
```

```
## [1] "list"
```

---
# `sapply`

`sapply` sta per simplified-apply e (cerca) di restituire una versione più semplice di una lista, applicando la funzione ad ogni elemento della lista in input:


```r
res &lt;- sapply(my_list, mean)
res
```

```
##      vec1      vec2      vec3 
## 0.3948843 0.4930509 0.5873119
```

```r
class(res)
```

```
## [1] "numeric"
```

---
# `apply`

`apply` funziona in modo specifico per dataframe o matrici, applicando una funzione alle righe o alle colonne:

- `apply(dataframe, index, fun)`


```r
# index 1 = riga, 2 = colonna
my_dataframe &lt;- data.frame(my_list)
head(my_dataframe)
```

```
##         vec1       vec2      vec3
## 1 0.06334647 0.20065912 0.5648194
## 2 0.02050063 0.56592647 0.5822552
## 3 0.31770826 0.30222668 0.7245719
## 4 0.15090245 0.55549511 0.8994042
## 5 0.76543851 0.78704433 0.1235824
## 6 0.45015420 0.04479232 0.3686716
```

```r
apply(my_dataframe, 1, mean)
```

```
##  [1] 0.2762750 0.3895608 0.4481689 0.5352672 0.5586884 0.2878727
##  [7] 0.7269706 0.3464056 0.5724929 0.7757882
```

```r
apply(my_dataframe, 2, mean)
```

```
##      vec1      vec2      vec3 
## 0.3948843 0.4930509 0.5873119
```

```r
apply(my_dataframe, 2, center_var)
```

```
##              vec1         vec2         vec3
##  [1,] -0.33153782 -0.292391743 -0.022492558
##  [2,] -0.37438365  0.072875603 -0.005056755
##  [3,] -0.07717602 -0.190824182  0.137259948
##  [4,] -0.24398183  0.062444252  0.312092212
##  [5,]  0.37055422  0.293993472 -0.463729519
##  [6,]  0.05526991 -0.448258546 -0.218640318
##  [7,]  0.50901338 -0.030405116  0.227056410
##  [8,] -0.24430596  0.146481283 -0.338205757
##  [9,]  0.28049281 -0.006862743 -0.031398346
## [10,]  0.05605496  0.392947720  0.403114683
```

---
# `tapply`

`tapply` permette di applicare una funzione ad un *vettore*, dividendo questo vettore in base ad una variabile categoriale:

- `tapply(dataframe, index, fun)`: dove `index` è un vettore di stringa o un fattore


```r
vec &lt;- rnorm(75)
index &lt;- rep(c("a", "b", "c"), each = 25)

tapply(vec, index, mean)
```

```
##           a           b           c 
## -0.06812406  0.10308278 -0.28704063
```

---
# `vapply`

`vapply` è una versione più *solida* delle precedenti dal punto di vista di programmazione. In pratica permette (e richiede) di specificare in anticipo la tipologia di dato che ci aspettiamo come risultato

`vapply(X = , FUN = , FUN.VALUE =  ,... )`


```r
vapply(my_list, FUN = mean, FUN.VALUE = numeric(length = 1))
```

```
##      vec1      vec2      vec3 
## 0.3948843 0.4930509 0.5873119
```

- `my_list, FUN = mean`: è esattamente uguale a `sapply/lapply`
- `FUN.VALUE = numeric(length = 1)`: indica che ogni risultato è un singolo valore numerico

---
# `mapply`

Questa è quella più complicata ma anche molto utile. Praticamente permette di gestire più liste contemporaneamente per scenari più complessi. Ad esempio vogliamo usare la funzione `rnorm()` e generare vettori con diverse **medie** e **deviazioni stardard** in combinazione.


```r
medie &lt;- list(10, 20, 30, 40)
stds &lt;- list(1,2,3,4)
mapply(function(x, y) rnorm(n = 10, mean = x, sd = y), medie, stds, SIMPLIFY = FALSE)
```

```
## [[1]]
##  [1] 10.217848  9.360606 13.005355 10.827983  9.938050  9.704575
##  [7] 10.177650  7.538134  8.786802 10.935674
## 
## [[2]]
##  [1] 18.71908 19.69118 19.17519 19.32460 20.90808 17.94136 20.95079
##  [8] 18.73810 21.03897 21.50396
## 
## [[3]]
##  [1] 30.24174 31.32946 29.61143 25.71072 29.04013 30.04381 24.00453
##  [8] 28.48768 32.28345 34.07652
## 
## [[4]]
##  [1] 39.87841 41.32449 43.16805 44.56794 37.67099 41.34128 39.95429
##  [8] 37.79135 33.13049 46.09267
```

**IMPORTANTE**, tutte le liste incluse devono avere la stessa dimensione!

---
# `mapply`


```r
mapply(function(x, y) rnorm(n = 10, mean = x, sd = y), medie, stds, SIMPLIFY = FALSE)
```

- `function(...)`: è una funzione anonima come abbiamo visto prima che può avere *n* elementi
- `rnorm(n = 10, mean = x, sd = y)`: è l'effettiva funzione anonima dove abbiamo i placeholders `x` and `y`
- `medie, stds`: sono **in ordine** le liste corrispondenti ai placeholders indicati, quindi `x = medie` e `y = stds`.
- `SIMPLIFY = FALSE`: semplicemente dice di restituire una lista e non cercare (come `sapply`) di semplificare il risultato

---
# `mapply` come `for`

Lo stesso risultato (in modo più verboso e credo meno intuitivo) si ottiene con un `for` usando più volte l'iteratore `i`:


```r
medie &lt;- list(10, 20, 30, 40)
stds &lt;- list(1,2,3,4)

res &lt;- vector(mode = "list", length = length(medie))

for(i in 1:length(medie)){
    res[[i]] &lt;- rnorm(10, mean = medie[[i]], sd = stds[[i]])
}

res
```

```
## [[1]]
##  [1]  9.583289  9.806524 10.432943  9.529109  8.142277  8.351309
##  [7]  9.848554  9.775408 10.765324 11.538047
## 
## [[2]]
##  [1] 22.65374 24.26623 21.44645 16.06632 21.58933 20.32876 17.56109
##  [8] 24.14780 19.81654 23.21469
## 
## [[3]]
##  [1] 30.45212 31.72261 30.57143 34.48696 27.49296 29.89705 28.73586
##  [8] 29.60271 32.82199 26.94086
## 
## [[4]]
##  [1] 43.74062 37.09056 36.47734 31.52933 44.00050 37.19971 48.51528
##  [8] 39.42331 46.52028 40.55219
```

---
class: section, center, middle

# `*apply` alcune precisazioni

---
# `*apply` vettore vs lista

Abbiamo sempre usato esplicitamente `liste` fino ad ora, ma le funzioni `*apply` sono direttamente applicabili anche a **vettori**

- se usiamo un vettore di *n* elementi, allora itereremo da `1:n`
- se usiamo una lista di *n* elementi, allora iteriamo da `1:n` dove il singolo elemento può essere qualsiasi cosa


```r
my_vec &lt;- 1:5
my_list &lt;- list(a = 1:2, b = 3:4, c = 5:6)
res &lt;- sapply(my_vec, print)
```

```
## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
```

```r
res &lt;- sapply(my_list, print)
```

```
## [1] 1 2
## [1] 3 4
## [1] 5 6
```

---
# `*apply` come un `for`

Nulla ci vieta (ma perdiamo l'aspetto intuitivo e conciso) di usare le funzioni `*apply` esattamente come un ciclo `for`, usando un **iteratore**:


```r
medie &lt;- c(10, 20, 30, 40)
stds &lt;- c(1,2,3,4)

res &lt;- lapply(1:length(medie), function(i){
    rnorm(n = 10, mean = medie[i], sd = stds[i])
})
```

Trovo tuttavia più chiara l'alternativa usando `mapply`:


```r
mapply(function(x, y) rnorm(n = 10, mean = x, sd = y), medie, stds, SIMPLIFY = FALSE)
```

---
class: section, center, middle

# Extra: `purrr::map*`

---
# Extra: `purrr::map*`

.pull-left[


```r
put_image("purrr.svg")
```

&lt;img src="img/purrr.svg" style="display: block; margin: auto;" /&gt;

]

.pull-right[

Senza addentrarci troppo in questo modo, c'è una famiglia di funzioni che una volta imparato `*apply` vi consiglio di usare perchè più consistenti e intuitive, la `map*` family.

]

---
# Extra: `purrr::map*`

Per usare `purrr::map*` è sufficiente installare il pacchetto `purrr` con `install.packages("purrr")` ed iniziare ad usare le nuove funzioni. La sintassi è esattamente la stessa di `*apply` (qualche modifica ma potete usare la stessa) ma invece che usare una funzione per tutto, abbiamo molte funzioni per ogni casistica:

- `map(lista, funzione)` è l'analogo di `lapply()` e fornisce sempre una lista

- `map_dbl(lista, funzione)` applica la funzione ad ogni elemento e **si aspetta che** il risultato sia un vettore di *double*
- `map_lgl(lista, funzione)` applica la funzione ad ogni elemento e **si aspetta che** il risultato sia un vettore *logico*
- `map2/pmap_*` sono rispettivamente applicare la funzione a 2/n liste (analogo di `mapply()`)

---
class: section, center, middle

# Extra: `replicate()` and `repeat()`

---
# Extra: `replicate()` and `repeat()`

Ci sono altre due funzioni in R che permettono di *iterare*. Sono meno utilizzate perchè si ottengono gli stessi risultati usando un semplice `for` o `*apply`.

- `replicate()` permette di ripetere un operazione *n* volte, senza però utilizzare un `iteratore` o un `placeholder`.
- `repeat()` anche repeat permette di ripetere ma fino a che non si verifica un certa condizione (**logica**). Ha una struttura simile al ciclo `while`

---
class: section, center, middle

# Extra: Formula syntax

---
# Formula syntax

In R molte operazioni vengono eseguite usando la **formula syntax** `something ~ something else` ad esempio:

- modelli statistici: `lm(y ~ x, data = data)`, `t.test(y ~ factor, data = data)`
- plot: `boxplot(y ~ x, data = data)`
- ...

In cosa consiste?

---
# Formula syntax

Senza andare nei dettagli tecnici, R usa una cosa che si chiama *lazy evaluation*. In altri termini "salva" delle operazioni per essere eseguite in un secondo momento. Tutti sappiamo che se scriviamo un nome (senza virgolette) e questo non è associato ad un oggetto otteniamo un errore. Tuttavia alcune funzioni come `library()` non forniscono errore. Perchè?


```r
stats # errore
```

```
## Error in eval(expr, envir, enclos): object 'stats' not found
```

```r
library(stats) # no errore
```

---
# Formula syntax

La ragione è che R è in grado di salvare un'espressione per usarla poi in uno specifico contesto (ad esempio dentro una funzione). La `formula syntax` è un esempio. Usando la tilde `~` possiamo creare delle `formule` che R può utilizzare in specifici contesti:


```r
y
```

```
##  [1] a a a a a a a a a a b b b b b b b b b b c c c c c c c c c c
## Levels: a b c
```

```r
x
```

```
##   [1]  0.548780692 -0.013271766 -0.790486370 -0.677608915 -0.880656308
##   [6]  0.322571450  0.757616224  0.239622711 -1.450565353 -0.639524142
##  [11] -0.385551842 -0.104084813 -0.868282111 -0.084581639 -0.220270553
##  [16]  0.711413800  0.552170936 -0.009849403 -0.030422203  0.985722609
##  [21]  1.054565142 -1.305977156  0.713322755  0.336700402  0.708956048
##  [26]  0.188975160  0.950777372  1.550747314 -0.420319919  1.931702302
##  [31]  0.297833095 -1.266590069 -0.078810262 -0.215787857 -0.878547132
##  [36] -0.080663257 -1.570554072  0.084115851 -0.717444447  0.472594802
##  [41] -0.379085505 -0.420971153 -0.560691956 -0.264071266  0.537903860
##  [46] -1.051840027 -0.531738704 -1.323221751  0.120666806 -0.752909532
##  [51]  0.706403831  1.709746823  0.530765468  0.261846100  1.047349262
##  [56] -0.819878364  0.748510459 -0.887815647  0.931846968  0.992776990
##  [61] -0.053454236  0.513581966  0.742931568 -1.190298532  0.570814783
##  [66]  0.029092209  0.704928330 -0.319562258  0.052809342  0.522432356
##  [71]  0.166005250  0.281148798  0.218854137 -0.704414717  2.520672483
##  [76]  0.225196174 -0.162068454 -1.442233944 -0.836277203 -1.718125281
##  [81] -0.926677451  0.520329383 -0.343112805  0.541792926 -0.268750755
##  [86]  2.840565115 -0.755718563 -0.482492270 -1.124478655 -0.545094694
##  [91] -0.336148581  1.254981522 -0.293385333 -1.108066526  0.643502157
##  [96]  0.628056927 -1.617970320  0.877628563  1.349458201  0.563340809
```

```r
y ~ x
```

```
## y ~ x
## &lt;environment: 0x561f60d4a7b8&gt;
```

```r
my_formula &lt;- y ~ x
class(my_formula)
```

```
## [1] "formula"
```

---
# Formula syntax e `aggregate()`

Un esempio utile è la funzione `aggregate()` molto interessante per applicare funzioni a dataframe. Immaginate di avere il dataset `iris` e calcolare la media per ogni livello del fattore `Species`:


```r
tapply(iris$Sepal.Length, iris$Species)
```

```
##   [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
##  [35] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
##  [69] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3
## [103] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
## [137] 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```

```r
aggregate(Sepal.Length ~ Species, FUN = mean, data = iris)
```

```
##      Species Sepal.Length
## 1     setosa        5.006
## 2 versicolor        5.936
## 3  virginica        6.588
```

```r
# Anche creando un oggetto, ma solo come formula

my_formula &lt;- Sepal.Length ~ Species
my_char &lt;- "Sepal.Length ~ Species"
aggregate(my_char, FUN = mean, data = iris)
```

```
## Error in aggregate.data.frame(as.data.frame(x), ...): argument "by" is missing, with no default
```

```r
# Viene lo stesso usando $ e senza specificare data =
aggregate(iris$Sepal.Length, iris$Species, FUN = mean)
```

```
## Error in aggregate.data.frame(as.data.frame(x), ...): 'by' must be a list
```
---

# Formula syntax e `aggregate()`

Ma anche operazioni più complesse:


```r
my_iris &lt;- iris
my_iris$fac &lt;- rep(c("a", "b", "c"), 50)
aggregate(Sepal.Length ~ Species + fac, mean, data = my_iris)
```

```
##      Species fac Sepal.Length
## 1     setosa   a     5.052941
## 2 versicolor   a     5.770588
## 3  virginica   a     6.756250
## 4     setosa   b     5.011765
## 5 versicolor   b     6.018750
## 6  virginica   b     6.447059
## 7     setosa   c     4.950000
## 8 versicolor   c     6.023529
## 9  virginica   c     6.570588
```

---
# Replicate

.pull-left[

`replicate(n, expr)`

- `n` è il numero di ripetizioni
- `expr` è la porzione di codice da ripetere


```r
# Campioniamo 1000 volte da una normale e facciamo la media AKA distribuzione campionaria della media

nrep &lt;- 1000
nsample &lt;- 30
media &lt;- 100
ds &lt;- 30

means &lt;- replicate(n = nrep, expr = {
    mean(rnorm(nsample, media, ds))
})
```

]

.pull-right[

&lt;img src="4_programmazione_files/figure-html/unnamed-chunk-56-1.png" width="2100" style="display: block; margin: auto;" /&gt;

]

---
# `repeat()`


```r
repeat {
    # cose da ripetere
    
    if(...){ # condizione da valutare
        
        break # ferma il loop
    }
}
```


```r
i &lt;- 1

repeat {
    print(i)
    i = i + 1
    if(i &gt; 3){
        break
    }
}
```

```
## [1] 1
## [1] 2
## [1] 3
```

---
# `repeat()` vs `while`

&lt;!-- TODO revise repeat vs loop --&gt;

.pull-left[


```r
i &lt;- 1

repeat {
    print(i)
    i = i + 1
    if(i &gt; 3){
        break
    }
}
```

```
## [1] 1
## [1] 2
## [1] 3
```
]

.pull-right[


```r
i &lt;- 1

while(i &lt; 4){
    print(i)
    i &lt;- i + 1
}
```

```
## [1] 1
## [1] 2
## [1] 3
```
]

- `repeat` valuta la condizione una volta finita l'iterazione, mentre `while` all'inizio. Se la condizione non è `TRUE` all'inizio, il `while` non parte mentre `repeat` si.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"highlightLanguage": "r",
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
