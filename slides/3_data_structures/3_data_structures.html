<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>title</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link rel="stylesheet" href="resources/arca.css" type="text/css" />
    <link rel="stylesheet" href="resources/arca_fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">






class: title-slide, center, middle

#.title[Strutture dati in R]

#.subtitle[Giornata 2]

&lt;img src="img/arca_logo.svg" width="10%" style="display: block; margin: auto;" /&gt;


###.location[Corsi ARCA - @DPSS]

###.author[Filippo Gambarota]

---

# Strutture dati

- Finora abbiamo visto oggetti semplici, tuttavia poter creare, manipolare e gestire **strutture dati complesse** è fondamentale in R.

- Le strutture dati sono modalità di **immagazzinare diverse informazioni** con una certa logica e utile per eseguire altre operazioni complesse.

---
# Strutture dati

Tutti voi avete presente un foglio di calcolo:


```r
put_image("foglio_excel.png")
```

&lt;img src="img/foglio_excel.png" width="88" style="display: block; margin: auto;" /&gt;

---
# Strutture dati in R

In R sono presenti diverse strutture dati di diversa complessità:

- Vettori
- Fattori
- Matrici
- Dataframe
- Liste

---
# Attributi

Gli oggetti in R possiedono degli **attributi** che forniscono informazioni aggiuntive:

- *nomi*: possiamo fornire delle etichette ad ogni elemento
- *dimensioni*: fornisce il numero di elementi per ogni dimensione nell'oggetto

---
# Come affrontarle?

- Creazione
- Attributi
- Indicizzazione
- Manipolazione
- Operazioni (se rilevante)

---
class: section, center, middle

# Vettori - The big picture

---


```r
put_image("vectors_diagram.svg")
```

&lt;img src="img/vectors_diagram.svg" style="display: block; margin: auto;" /&gt;

---

# Vettori - Disclaimer

I vettori (**atomic**) sono una struttura dati *unidimensionale* e sono la più semplice presente in R. Ci sono alcune cose importanti:

- Possono contenere informazioni di una sola *tipologia* (come numeri, stringhe, etc.)
- Essendo *unidimensionali* ogni elemento corrisponde ad una posizione
- Sono l'elemento fondante di strutture dati più complesse come matrici e dataframe
- Quelli che in R si chiamano `vectors` sono gli `atomic vectors` perchè anche le `liste` (che vedremo) sono dei `vectors` ma che possono contenere elementi eterogenei

---
# Vettori


```r
put_image("vector.png")
```

&lt;img src="img/vector.png" width="409" style="display: block; margin: auto;" /&gt;

---
# Vettori - creazione

Per creare un vettore si usa la funzione `c()` che sta per **concatenazione** e permette appunto di unire una serie di elementi:

.pull-left[


```r
my_int &lt;- c(1:10) # vettore di interi
my_int
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
my_dbl &lt;- c(1.2, 3.4, 5.5) # vettore di double
my_dbl
```

```
## [1] 1.2 3.4 5.5
```

```r
my_lgl &lt;- c(TRUE, FALSE, TRUE)
my_lgl
```

```
## [1]  TRUE FALSE  TRUE
```

```r
my_chr &lt;- c("ciao", "come", "stai")
my_chr
```

```
## [1] "ciao" "come" "stai"
```
]

.pull-right[


```r
class(my_int)
```

```
## [1] "integer"
```

```r
class(my_dbl)
```

```
## [1] "numeric"
```

```r
class(my_lgl)
```

```
## [1] "logical"
```

```r
class(my_chr)
```

```
## [1] "character"
```

]

---
# `is.*` e `as.*` family

Possiamo *testare* o *convertire* (quando possibile) la tipologia di un vettore usando le funzioni `is.*` e `as.*`:


```r
is.integer(my_int)
```

```
## [1] TRUE
```

```r
my_dbl
```

```
## [1] 1.2 3.4 5.5
```

```r
as.integer(my_dbl)
```

```
## [1] 1 3 5
```

```r
as.integer(my_lgl) # cosa succede di strano?
```

```
## [1] 1 0 1
```

```r
as.numeric(my_chr) # cosa succedere di strano?
```

```
## Warning: NAs introduced by coercion
```

```
## [1] NA NA NA
```

---
# I valori `NA`

C'è una sola tipologia di dato che può coesistere in un vettore (atomic) e sono gli `NA` (**N**ot **A**pplicable) e rappresentano dei valori mancanti per varie ragioni:


```r
my_int &lt;- c(1,2,5,"ciao") # convertito a stringa
my_int
```

```
## [1] "1"    "2"    "5"    "ciao"
```

```r
my_int &lt;- c(1,2,3, NA) # NA viene convertito in numeric
my_int
```

```
## [1]  1  2  3 NA
```

Quello che succede in realtà è che ci sono altrettante tipologie di `NA` come `NA_logical_`, `NA_integer_` etc. e viene usato quello compatibile con il resto del vettore.

---
# Vettori - Attributi

Gli attributi possibili per un vettore (atomic) sono:
- `names()`: ogni elemento può essere associato ad un nome/etichetta
- Dimensione (`dim()`), in realtà con il vettore unidimensionale usiamo `length()`


```r
x &lt;- 1:10
names(x) # di default non ci sono nomi
```

```
## NULL
```

```r
names(x) &lt;- letters[1:10] # assegnamo una lettera ad ogni posizione
setNames(x, letters[1:10]) # modo alternativo
```

```
##  a  b  c  d  e  f  g  h  i  j 
##  1  2  3  4  5  6  7  8  9 10
```

```r
dim(x) # NULL
```

```
## NULL
```

```r
length(x) # ci fornisce la lunghezza
```

```
## [1] 10
```

---
# Vettori - Indicizzazione

L'indicizzazione dei vettori è la più semplice essendo *unidimensionali*. Essendo l'unica proprietà la **lunghezza** (`length(vettore)`) possiamo selezionare, eliminare, estrarre elementi semplicemente usando l'**indice di posizione** tramite le parentesi quadre `vettore[pos]`:


```r
my_vec &lt;- round(runif(20, 1, 100))
my_vec
```

```
##  [1] 82 10 39 28 25 32 18 32 76  9  7 11  2 96 53 41 70 92 58 94
```

```r
my_vec[1] # estraggo il primo elemento
```

```
## [1] 82
```

```r
my_vec[1:10] # estraggo i primi 10 elementi
```

```
##  [1] 82 10 39 28 25 32 18 32 76  9
```

```r
my_vec[c(1,5,10,16)] # estraggo n elementi a varie posizioni
```

```
## [1] 82 25  9 41
```

```r
my_vec[length(my_vec)] # estraggo l'ultimo elemento
```

```
## [1] 94
```

---
# Vettori - Indicizzazione

Possiamo anche indicizzare (meno comune) con i nomi (se li abbiamo impostati come nella slide *attributi*):


```r
x &lt;- 1:10
names(x) &lt;- letters[1:10]
x["a"]
```

```
## a 
## 1
```

```r
x[c("a", "b", "c")]
```

```
## a b c 
## 1 2 3
```

In generale comunque non è molto comune usare i nomi per i vettori ma in alcuni casi può essere utile.

---
# Vettori - Indicizzazione Logica

Indicizzare con la posizione è l'aspetto più semplice e intuitivo. E' possibile anche selezionare tramite valori `TRUE` e `FALSE`. L'idea è che se abbiamo un vettore di lunghezza *n* e un'altro vettore logico di lunghezza *n*, tutti gli elementi `TRUE` saranno selezionati:


```r
my_vec &lt;- 1:10
my_selection &lt;- sample(rep(c(TRUE, FALSE), each = 5)) # random TRUE/FALSE
my_selection
```

```
##  [1] FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE
```

```r
my_vec[my_selection]
```

```
## [1] 2 3 4 5 8
```

---
# Vettori - Indicizzazione Logica

Chiaramente non è pratico costruire a mano i vettori logici. Infatti possiamo usare delle *espressioni relazionali* per selezionare elementi:


```r
my_vec &lt;- 1:10
my_selection &lt;- my_vec &lt; 6
my_vec[my_selection]
```

```
## [1] 1 2 3 4 5
```

```r
my_vec[my_vec &lt; 6] # in modo più compatto
```

```
## [1] 1 2 3 4 5
```

---
# Vettori - Indicizzazione Logica

Chiaramente possiamo usare **espressioni di qualsiasi complessità** perchè essenzialmente abbaimo bisogno di un vettore `TRUE/FALSE`:


```r
my_vec &lt;- 1:10
my_selection &lt;- my_vec &lt; 2 | my_vec &gt; 8
my_vec[my_selection]
```

```
## [1]  1  9 10
```

```r
my_vec[my_vec &lt; 2 | my_vec &gt; 8] # in modo più compatto
```

```
## [1]  1  9 10
```

---
# Vettori - Indicizzazione Logica `which()`

La funzione `which()` è molto utile perchè restituisce la **posizione** associata ad una selezione logica:


```r
my_vec &lt;- rnorm(10)
which(my_vec &lt; 0.5)
```

```
## [1]  1  2  3  5  7  8  9 10
```

```r
# Questo

my_vec[which(my_vec &lt; 0.5)]
```

```
## [1]  0.1962468 -0.9215189 -0.8289959 -0.4277440 -1.4345534 -1.5717688  0.3181297 -1.0608736
```

```r
# e questo sono equivalenti

my_vec[my_vec &lt; 0.5]
```

```
## [1]  0.1962468 -0.9215189 -0.8289959 -0.4277440 -1.4345534 -1.5717688  0.3181297 -1.0608736
```

---
# Vettori - Indicizzazione Negativa `-`

Allo stesso modo di selezionare elementi con `[]`, indici di posizione e indici logici è possibile "rimuovere" degli elementi da un vettore, o in altri termini **non** selezionare alcuni elementi tramite il segno meno `-`:


```r
my_vec &lt;- 1:10

my_vec[-c(1,2)] # rimuovo i primi 2
```

```
## [1]  3  4  5  6  7  8  9 10
```

```r
my_vec[!my_vec &gt; 5] # rimuovo i maggiori di 5, chiaramente uguale a selezionare i minori
```

```
## [1] 1 2 3 4 5
```

---

class: section, center, middle

# Fattori

---
# Fattori

I fattori sono una tipologia di dato peculiare e per quanto simile a semplici `characters` in realtà sono un tipo di vettore `integer` con delle proprietà aggiuntive.


```r
put_image("factors.png")
```

&lt;img src="img/factors.png" width="80" style="display: block; margin: auto;" /&gt;

---
# Fattori - Creazione

I fattori si creano in modi diversi sia convertendo un vettore `character` con `as.factor()` che creando esplicitamente un fattore con `factor()`:


```r
my_chr &lt;- rep(c("a", "b", "c"), c(3, 4, 2))
as.factor(my_chr)
```

```
## [1] a a a b b b b c c
## Levels: a b c
```

```r
my_fac &lt;- factor(my_chr)
my_fac
```

```
## [1] a a a b b b b c c
## Levels: a b c
```

---
# Fattori - Attributi

I fattori fanno ampiamente uso degli attributi in particolare:


```r
typeof(my_fac)
```

```
## [1] "integer"
```

```r
attributes(my_fac)
```

```
## $levels
## [1] "a" "b" "c"
## 
## $class
## [1] "factor"
```

```r
# Notate la differenza tra
as.integer(my_fac)
```

```
## [1] 1 1 1 2 2 2 2 3 3
```

```r
# e
as.integer(my_chr)
```

```
## Warning: NAs introduced by coercion
```

```
## [1] NA NA NA NA NA NA NA NA NA
```

I fattori quindi permettono di avere dei livelli `levels()` come metadati, a prescindere da quali sono effettivamente presenti nel vettore

---
# Fattori - Indicizzazione

L'indicizzazione è esattamente la stessa che per i vettori atomic (essendo i fattori degli `integers`) tuttavia anche la selezione preserverà i metadati:


```r
my_fac[1]
```

```
## [1] a
## Levels: a b c
```

```r
my_fac[1:5]
```

```
## [1] a a a b b
## Levels: a b c
```

---
# Fattori Ordinali (extra)

Un sottotipo dei fattori sono gli `ordered factors` che corrispondo alle variabili ordinali, ovvero dove i livelli sono ordinati in modo crescente:


```r
my_ord_fac &lt;- as.ordered(my_fac)
my_ord_fac
```

```
## [1] a a a b b b b c c
## Levels: a &lt; b &lt; c
```

```r
attributes(my_ord_fac)
```

```
## $levels
## [1] "a" "b" "c"
## 
## $class
## [1] "ordered" "factor"
```

---
class: section, center, middle

# Liste

---
# Liste

La lista è una generalizzazione dell' **atomic vector** dove:

- i **dati** possono essere di **diversa tipologia**
- ogni elemento può essere **a sua volta una lista**
- sono una struttura dati *unidimensionale* ma possono svilupparsi in **profondità** (ci arriviamo)


```r
put_image("list_vs_vector.svg")
```

&lt;img src="img/list_vs_vector.svg" style="display: block; margin: auto;" /&gt;

---
# Liste

.pull-left[


```r
put_image("list_example.png")
```

&lt;img src="img/list_example.png" width="166" style="display: block; margin: auto;" /&gt;

]

.pull-right[


```r
put_image("list_depth.png")
```

&lt;img src="img/list_depth.png" width="215" style="display: block; margin: auto;" /&gt;

]

---
# Liste - Creazione

Per creare una lista si può usare il comando list, specificando gli elementi ed eventualmente un nome associato ad ogni elemento:


```r
my_list &lt;- list(
    1:10,
    rep(c("a", "b", "c"), each = 3),
    my_fac
)

my_list
```

```
## [[1]]
##  [1]  1  2  3  4  5  6  7  8  9 10
## 
## [[2]]
## [1] "a" "a" "a" "b" "b" "b" "c" "c" "c"
## 
## [[3]]
## [1] a a a b b b b c c
## Levels: a b c
```

---

# Liste - Attributi

Come per i vettori anche le liste hanno una lunghezza (`lenght()`) ed eventualmente dei nomi (`names()`). Il comando `str()` (struttura) è molto utile per le liste perchè fornisce una visione sulla struttura:


```r
names(my_list)
```

```
## NULL
```

```r
length(my_list)
```

```
## [1] 3
```

```r
str(my_list)
```

```
## List of 3
##  $ : int [1:10] 1 2 3 4 5 6 7 8 9 10
##  $ : chr [1:9] "a" "a" "a" "b" ...
##  $ : Factor w/ 3 levels "a","b","c": 1 1 1 2 2 2 2 3 3
```

```r
names(my_list) &lt;- c("elemento1", "elemento2", "elemento3")
```

---
# Liste - Indicizzazione

L'indicizzazione è più "complessa" ma molto simile ai vettori. Possiamo indicizzare con parentesi quadre `lista[n]` o con le doppie parentesi quadre `lista[[n]]`. Se a lista è una `named list` quindi con associati i nomi, possiamo usare `$` con il nome associato `lista$nome_elemento`:


```r
my_list[1] # accedo al primo elemento COME LISTA
```

```
## $elemento1
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
my_list[[1]] # accedo al primo elemento
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
my_list$elemento1 # accedo con il nome
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
my_list["elemento1"]
```

```
## $elemento1
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
my_list[["elemento1"]]
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

---
# Liste - Indicizzazione

La differenza tra le parentesi quadre riguarda il fatto se vogliamo fare un subset della lista ottenendo un'altra lista oppure se vogliamo accedere direttamente all'elemento interno.

Se vogliamo selezionare più elementi (quindi fare un vero e proprio subset della lista) dobbiamo sempre usare le paarentesi quadre singole:


```r
my_list[1:2]
```

```
## $elemento1
##  [1]  1  2  3  4  5  6  7  8  9 10
## 
## $elemento2
## [1] "a" "a" "a" "b" "b" "b" "c" "c" "c"
```

```r
my_list[[1:2]]
```

```
## [1] 2
```

---
# Liste - Indicizzazione Nested

Come abbiamo visto le liste possono contenere altre liste, ottendo una struttura *unidimensionale* ma che si può sviluppare in profondità. Per selezionare elementi *nested* si possono concatenare più parentesi:


```r
my_list &lt;- list(1:10, letters[1:10], rnorm(10))
my_list &lt;- list(my_list, rnorm(10), rnorm(10))
str(my_list)
```

```
## List of 3
##  $ :List of 3
##   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
##   ..$ : chr [1:10] "a" "b" "c" "d" ...
##   ..$ : num [1:10] -0.6951 -1.4453 -0.1342 -0.0323 -2.2123 ...
##  $ : num [1:10] 0.328 -0.248 -0.303 -2.174 -1.456 ...
##  $ : num [1:10] -0.868 1.469 -1.238 2.285 1.547 ...
```

---
# Liste - Indicizzazione Nested


```r
my_list[[1]][[1]] # primo elemento della prima lista
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
my_list[[1]][[1]][[1]] # primo elemento del primo elemento della prima lista
```

```
## [1] 1
```

C'è anche un modo meno intuitivo ma equivalente per indicizzare in modo ricorsivo:


```r
my_list[[c(1,2)]] # equivalente a my_list[[1]][[2]]
```

```
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j"
```

---
class: section, center, middle

# Matrici

---
# Matrici - Creazione

Le matrici sono una struttura dati *bidimensionale* caratterizzate da `righe` e `colonne` ovvero le dimensioni `dim()` dove il numero di righe rappresenta la dimensione 1 e il numero di colonne la dimensione 2. La matrice si crea con il comando `matrix(data, nrow, ncol, byrow =, dimnames=)`:


```r
# usare indici progressivi come dato è utile per capire l'argomento byrow

my_mat &lt;- matrix(data = 1:9, ncol = 3, nrow = 3, byrow = FALSE)
my_mat
```

```
##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9
```

```r
t(my_mat) # inverte righe e colonne, equivalente a mettere byrow = TRUE
```

```
##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6
## [3,]    7    8    9
```

```r
dim(my_mat)
```

```
## [1] 3 3
```

```r
attributes(my_mat)
```

```
## $dim
## [1] 3 3
```

---
# Matrici - Creazione

Il numero di righe e colonne non deve essere lo stesso necessariamente (matrice quadrata) ma il numero di righe deve essere compatibile con il vettore `data`:


```r
matrix(data = 1:100, ncol = 3, nrow = 3)
```

```
## Warning in matrix(data = 1:100, ncol = 3, nrow = 3): data length [100] is not a sub-multiple or multiple
## of the number of rows [3]
```

```
##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9
```

```r
matrix(data = 1:9, ncol = 5, nrow = 5)
```

```
## Warning in matrix(data = 1:9, ncol = 5, nrow = 5): data length [9] is not a sub-multiple or multiple of
## the number of rows [5]
```

```
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    6    2    7    3
## [2,]    2    7    3    8    4
## [3,]    3    8    4    9    5
## [4,]    4    9    5    1    6
## [5,]    5    1    6    2    7
```

Cosa è successo alle matrici? E' un errore? Cosa fa R di default?

---
# Matrici - Creazione

Tendenzialmente le matrici sono usate per calcolo e statistica e non è comune usare dei nomi per le colonne/righe (vedi `dataframe`) ma usando il comando `dimnames =` o `dimnames(matrix) &lt;- list(rownames, colnames)`:


```r
# Ci serve una lista con nomi di righe e colonne
dim_names &lt;- list(
    c("row1", "row2", "row3"),
    c("col1", "col2", "col3")
)

my_mat &lt;- matrix(data = 1:9, ncol = 3, nrow = 3, dimnames = dim_names)
dimnames(my_mat) &lt;- dim_names
my_mat
```

```
##      col1 col2 col3
## row1    1    4    7
## row2    2    5    8
## row3    3    6    9
```

---
# Matrici - Operazioni

Senza andare nei meandri dell'algebra, le matrici (come i vettori) possono essere usati per operazioni matematiche:


```r
my_mat + my_mat
```

```
##      col1 col2 col3
## row1    2    8   14
## row2    4   10   16
## row3    6   12   18
```

```r
my_mat * my_mat
```

```
##      col1 col2 col3
## row1    1   16   49
## row2    4   25   64
## row3    9   36   81
```

```r
my_mat %*% my_mat
```

```
##      col1 col2 col3
## row1   30   66  102
## row2   36   81  126
## row3   42   96  150
```

```r
my_mat + 1
```

```
##      col1 col2 col3
## row1    2    5    8
## row2    3    6    9
## row3    4    7   10
```

---

# Matrici - Indicizzazione

Anche l'indicizzazione è un'estensione di quella per i vettori adattata alle due dimensioni. Per identificare uno o più elementi nella matrice abbiamo bisogno di **indici/e di riga e/o colonna** separati da **virgola**, sempre con le parentesi quadre: `matrice[riga, colonna]`:


```r
my_mat[1,1] # primo elemento della prima riga e colonna
```

```
## [1] 1
```

```r
my_mat[3,3]
```

```
## [1] 9
```

```r
my_mat[1, ] # tutta la prima riga
```

```
## col1 col2 col3 
##    1    4    7
```

```r
my_mat[ ,1] # tutta la prima colonna
```

```
## row1 row2 row3 
##    1    2    3
```

---
# Matrici - Indicizzazione Logica

Come per i vettori anche la matrice può essere usata per operazioni *relazionali* ed essere indicizzata in modo logico:


```r
my_mat &gt; 4 # matrice logica
```

```
##       col1  col2 col3
## row1 FALSE FALSE TRUE
## row2 FALSE  TRUE TRUE
## row3 FALSE  TRUE TRUE
```

```r
my_mat[my_mat &gt; 4]
```

```
## [1] 5 6 7 8 9
```

Come vedete restituisce un vettore che rispetta la selezione, ma non una matrice.

---
# Matrici non numeriche

Questa (abbastanza inutile) variante delle matrici è possibile perchè come per i vettori possiamo avere matrici logiche, di stringhe etc. ma dati diversi non possono coesistere:


```r
my_mat &gt; 3
```

```
##       col1 col2 col3
## row1 FALSE TRUE TRUE
## row2 FALSE TRUE TRUE
## row3 FALSE TRUE TRUE
```

```r
is.logical(my_mat &gt; 3)
```

```
## [1] TRUE
```

```r
matrix("R", nrow = 3, ncol = 3) # notate che se l'argomento data è un solo elemento questo viene riciclato
```

```
##      [,1] [,2] [,3]
## [1,] "R"  "R"  "R" 
## [2,] "R"  "R"  "R" 
## [3,] "R"  "R"  "R"
```

L'indicizzazione è la medesima a prescindere dal tipo di dato, mentre le operazioni (matematiche) sono chiaramente possibili solo per matrici numeriche.

---

Come per i vettori ci sono alcune cose rilevanti:

- Possono contenere una sola tipologia di dati
- Essendo bidimensionali, abbiamo bisogno di due indici di posizione (righe e colonne) per identificare un elemento
- Possono essere viste come un insieme di singoli vettori

---
# Matrici - Attributi

In parte lo abbiamo già visto ma le matrici hanno come attributi la dimensione `dim()` ovvero il numero di righe `nrow()` e il numero di colonne `ncol()`. Inoltre le dimensioni possono avere anche un nome `dimnames()`:


```r
attributes(my_mat)
```

```
## $dim
## [1] 3 3
## 
## $dimnames
## $dimnames[[1]]
## [1] "row1" "row2" "row3"
## 
## $dimnames[[2]]
## [1] "col1" "col2" "col3"
```

```r
dim(my_mat)
```

```
## [1] 3 3
```

```r
ncol(my_mat)
```

```
## [1] 3
```

```r
nrow(my_mat)
```

```
## [1] 3
```

```r
dimnames(my_mat)
```

```
## [[1]]
## [1] "row1" "row2" "row3"
## 
## [[2]]
## [1] "col1" "col2" "col3"
```

---
# Matrici

Se per i vettori possiamo unire elementi con `c(1,2,3)` o unire vettori `c(vec1, vec2)` con le matrici possiamo usare i comandi `cbind()`
e `rowbind()`:


```r
put_image("matrix_comb.svg")
```

&lt;img src="img/matrix_comb.svg" style="display: block; margin: auto;" /&gt;
---
# Extra: Array

Gli array sono degli oggetti *n-dimensionali*. Se la matrice è un quadrato un array è un cubo. Valgono le stesse proprietà della matrice chiaramente scalate alle *n dimensioni*:


```r
my_array &lt;- array(1:27, dim = c(3,3,3)) # esempio tridimensionale
my_array
```

```
## , , 1
## 
##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9
## 
## , , 2
## 
##      [,1] [,2] [,3]
## [1,]   10   13   16
## [2,]   11   14   17
## [3,]   12   15   18
## 
## , , 3
## 
##      [,1] [,2] [,3]
## [1,]   19   22   25
## [2,]   20   23   26
## [3,]   21   24   27
```

---
# Extra: Array

L'indicizzazione avviene allo stesso modo delle matrici aggiungendo una dimensione: `my_array[riga, colonna, dimensione]`


```r
my_array[1,1,1] # prima riga, prima colonna, prima "fetta"
```

```
## [1] 1
```

Anche gli attributi sono gli stessi ma chiaramente scalati su *n* dimensioni. Le dimensioni sono potenzialmente "infinite" ma aumenta anche la complessità e la
praticità della struttura dati. Ad esempio un array a 4 dimensioni è un insieme di array a 3 dimensioni (e già diventa complesso).

---
class: section, center, middle

# Dataframe

---
# Dataframe

Il dataframe è la struttura più "complessa", utile e potente di R. Da un punto di vista intuitivo è un *foglio excel* mentre da un punto di vista
di R è una tipologia di lista con alcune caratteristiche/restrizioni &lt;sup&gt;1&lt;/sup&gt;

- ogni elemento della lista è un **vettore con un nome associato** (aka una colonna)
- ogni **lista/colonna** deve avere lo **stesso numero di elementi**
- di conseguenza ogni **riga** ha lo **stesso numero di elementi** (struttura *rettangolare*)

.footnote[
[1] [Advanced R - Hadley Wickam](https://adv-r.hadley.nz/vectors-chap.html)
]

---
# Dataframe - Creazione

La creazione di un `dataframe` è molto simile alla lista tramite la funzione `data.frame(colonna_1, colonna_2, colonna_n)` 
dove ogni colonna è un vettore di uguale lunghezza.


```r
my_df &lt;-data.frame(
    colonna1 = 1:10,
    colonna2 = letters[1:10],
    colonna3 = rnorm(10),
    colonna4 = runif(10)
)
my_df
```

```
##    colonna1 colonna2    colonna3  colonna4
## 1         1        a -0.15269104 0.7064622
## 2         2        b  0.01002986 0.2277317
## 3         3        c  1.78092459 0.7939930
## 4         4        d -0.08934057 0.3957772
## 5         5        e  0.93034114 0.2935416
## 6         6        f -1.77902019 0.8144659
## 7         7        g  0.39769563 0.8064687
## 8         8        h -0.49707573 0.2663724
## 9         9        i  0.61406519 0.6635450
## 10       10        j -0.13872528 0.8183998
```
---
# Dataframe - Attributi

Vediamo che il `dataframe` ha infatti sia gli attributi della `lista` ovvero i `names` ma anche gli attributi della `matrice`
ovvero le dimensioni (righe e colonne):


```r
typeof(my_df) # è una lista
```

```
## [1] "list"
```

```r
attributes(my_df) # ma ha anche una classe dedicata
```

```
## $names
## [1] "colonna1" "colonna2" "colonna3" "colonna4"
## 
## $class
## [1] "data.frame"
## 
## $row.names
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
dim(my_df)
```

```
## [1] 10  4
```

```r
nrow(my_df)
```

```
## [1] 10
```

```r
ncol(my_df)
```

```
## [1] 4
```
---
# Dataframe - Indicizzazione

Anche per l'indicizzazione il dataframe acquisisce le proprietà della `matrice` e della `lista` con nomi associati. In particolare
posso usare le parentesi quadre `[]` oppure il simbolo del dollaro `$`:

.pull-left[


```r
# Indicizzazione come matrice
my_df[1,1]
```

```
## [1] 1
```

```r
my_df[1, ]
```

```
##   colonna1 colonna2  colonna3  colonna4
## 1        1        a -0.152691 0.7064622
```

```r
my_df[, 1]
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```
]

.pull-right[


```r
# Indicizzazione come matrice
my_df$colonna1
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```
]

---
# Dataframe - Indicizzazione

Per dimostrare che il dataframe è essenzialmente una matrice, possiamo usare la doppia parentesi quadra per estrarre
una colonna e non `[riga,colonna]`:


```r
my_df[[1]] # estraggo la prima colonna
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
my_df[["colonna1"]] # estraggo la prima colonna usando il nome
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```
---
# Dataframe - Indicizzazione

In generale, l'indicizzazione del dataframe è quella più complessa ed efficiente, sopratutto combinata con
**operazioni relazionali**:


```r
my_df[my_df$colonna1 &gt; 4, ]
```

```
##    colonna1 colonna2   colonna3  colonna4
## 5         5        e  0.9303411 0.2935416
## 6         6        f -1.7790202 0.8144659
## 7         7        g  0.3976956 0.8064687
## 8         8        h -0.4970757 0.2663724
## 9         9        i  0.6140652 0.6635450
## 10       10        j -0.1387253 0.8183998
```

```r
my_df[my_df$colonna1 &gt; 4 &amp; my_df$colonna4 &gt; 0.1, ]
```

```
##    colonna1 colonna2   colonna3  colonna4
## 5         5        e  0.9303411 0.2935416
## 6         6        f -1.7790202 0.8144659
## 7         7        g  0.3976956 0.8064687
## 8         8        h -0.4970757 0.2663724
## 9         9        i  0.6140652 0.6635450
## 10       10        j -0.1387253 0.8183998
```

```r
my_df[my_df$colonna1 &gt; 4, "colonna4"]
```

```
## [1] 0.2935416 0.8144659 0.8064687 0.2663724 0.6635450 0.8183998
```

```r
my_df[my_df$colonna1 &gt; 4, 1]
```

```
## [1]  5  6  7  8  9 10
```

# Dataframe - Indicizzazione

L'idea generale è semplice ovvero quando seleziono faccio operazioni sulle **righe** (seleziono alcune righe) ed eventualmente sulle
**colonne** (seleziono alcune colonne). Attenzione però a cosa viene restituito!


```r
typeof(my_df[1,1])
```

```
## [1] "integer"
```

```r
typeof(my_df[1, ])
```

```
## [1] "list"
```

```r
typeof(my_df[, 1])
```

```
## [1] "integer"
```
Viene restituito non sempre un dataframe, per evitare questo (se è necessario) possiamo usare `drop = FALSE`
per ottenere sempre un dataframe:


```r
typeof(my_df[, 1, drop = FALSE])
```

```
## [1] "list"
```

```r
typeof(my_df[1,1, drop = FALSE])
```

```
## [1] "list"
```
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "googlecode",
"highlightLines": true,
"highlightLanguage": "r",
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
